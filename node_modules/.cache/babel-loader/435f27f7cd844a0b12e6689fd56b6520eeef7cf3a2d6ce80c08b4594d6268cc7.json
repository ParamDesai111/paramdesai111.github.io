{"ast":null,"code":"import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont } from \"@tsparticles/engine\";\nexport const validTypes = [\"emoji\"];\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"';\nexport class EmojiDrawer {\n  constructor() {\n    this._emojiShapeDict = new Map();\n  }\n  destroy() {\n    for (const [key, emojiData] of this._emojiShapeDict) {\n      emojiData instanceof ImageBitmap && (emojiData === null || emojiData === void 0 ? void 0 : emojiData.close());\n      this._emojiShapeDict.delete(key);\n    }\n  }\n  draw(data) {\n    const {\n        context,\n        particle,\n        radius,\n        opacity\n      } = data,\n      emojiData = particle.emojiData;\n    if (!emojiData) {\n      return;\n    }\n    context.globalAlpha = opacity;\n    context.drawImage(emojiData, -radius, -radius, radius * 2, radius * 2);\n    context.globalAlpha = 1;\n  }\n  async init(container) {\n    const options = container.actualOptions;\n    if (validTypes.find(t => isInArray(t, options.particles.shape.type))) {\n      const promises = [loadFont(defaultFont)],\n        shapeOptions = validTypes.map(t => options.particles.shape.options[t]).find(t => !!t);\n      if (shapeOptions) {\n        executeOnSingleOrMultiple(shapeOptions, shape => {\n          shape.font && promises.push(loadFont(shape.font));\n        });\n      }\n      await Promise.all(promises);\n    }\n  }\n  particleDestroy(particle) {\n    delete particle.emojiData;\n  }\n  particleInit(container, particle) {\n    var _shapeData$font;\n    const shapeData = particle.shapeData;\n    if (!(shapeData !== null && shapeData !== void 0 && shapeData.value)) {\n      return;\n    }\n    const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData),\n      font = (_shapeData$font = shapeData.font) !== null && _shapeData$font !== void 0 ? _shapeData$font : defaultFont;\n    if (!emoji) {\n      return;\n    }\n    const key = \"\".concat(emoji, \"_\").concat(font),\n      existingData = this._emojiShapeDict.get(key);\n    if (existingData) {\n      particle.emojiData = existingData;\n      return;\n    }\n    const canvasSize = getRangeMax(particle.size.value) * 2;\n    let emojiData;\n    if (typeof OffscreenCanvas !== \"undefined\") {\n      const canvas = new OffscreenCanvas(canvasSize, canvasSize),\n        context = canvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n      context.font = \"400 \".concat(getRangeMax(particle.size.value) * 2, \"px \").concat(font);\n      context.textBaseline = \"middle\";\n      context.textAlign = \"center\";\n      context.fillText(emoji, getRangeMax(particle.size.value), getRangeMax(particle.size.value));\n      emojiData = canvas.transferToImageBitmap();\n    } else {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = canvasSize;\n      canvas.height = canvasSize;\n      const context = canvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n      context.font = \"400 \".concat(getRangeMax(particle.size.value) * 2, \"px \").concat(font);\n      context.textBaseline = \"middle\";\n      context.textAlign = \"center\";\n      context.fillText(emoji, getRangeMax(particle.size.value), getRangeMax(particle.size.value));\n      emojiData = canvas;\n    }\n    this._emojiShapeDict.set(key, emojiData);\n    particle.emojiData = emojiData;\n  }\n}","map":{"version":3,"names":["executeOnSingleOrMultiple","getRangeMax","isInArray","itemFromSingleOrMultiple","loadFont","validTypes","defaultFont","EmojiDrawer","constructor","_emojiShapeDict","Map","destroy","key","emojiData","ImageBitmap","close","delete","draw","data","context","particle","radius","opacity","globalAlpha","drawImage","init","container","options","actualOptions","find","t","particles","shape","type","promises","shapeOptions","map","font","push","Promise","all","particleDestroy","particleInit","_shapeData$font","shapeData","value","emoji","randomIndexData","concat","existingData","get","canvasSize","size","OffscreenCanvas","canvas","getContext","textBaseline","textAlign","fillText","transferToImageBitmap","document","createElement","width","height","set"],"sources":["C:/Users/84146/OneDrive/Documents/Portfolio/ParamDesai111.github.io/node_modules/@tsparticles/shape-emoji/browser/EmojiDrawer.js"],"sourcesContent":["import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nexport const validTypes = [\"emoji\"];\nconst defaultFont = '\"Twemoji Mozilla\", Apple Color Emoji, \"Segoe UI Emoji\", \"Noto Color Emoji\", \"EmojiOne Color\"';\nexport class EmojiDrawer {\n    constructor() {\n        this._emojiShapeDict = new Map();\n    }\n    destroy() {\n        for (const [key, emojiData] of this._emojiShapeDict) {\n            emojiData instanceof ImageBitmap && emojiData?.close();\n            this._emojiShapeDict.delete(key);\n        }\n    }\n    draw(data) {\n        const { context, particle, radius, opacity } = data, emojiData = particle.emojiData;\n        if (!emojiData) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        context.drawImage(emojiData, -radius, -radius, radius * 2, radius * 2);\n        context.globalAlpha = 1;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (validTypes.find((t) => isInArray(t, options.particles.shape.type))) {\n            const promises = [loadFont(defaultFont)], shapeOptions = validTypes\n                .map((t) => options.particles.shape.options[t])\n                .find((t) => !!t);\n            if (shapeOptions) {\n                executeOnSingleOrMultiple(shapeOptions, (shape) => {\n                    shape.font && promises.push(loadFont(shape.font));\n                });\n            }\n            await Promise.all(promises);\n        }\n    }\n    particleDestroy(particle) {\n        delete particle.emojiData;\n    }\n    particleInit(container, particle) {\n        const shapeData = particle.shapeData;\n        if (!shapeData?.value) {\n            return;\n        }\n        const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData), font = shapeData.font ?? defaultFont;\n        if (!emoji) {\n            return;\n        }\n        const key = `${emoji}_${font}`, existingData = this._emojiShapeDict.get(key);\n        if (existingData) {\n            particle.emojiData = existingData;\n            return;\n        }\n        const canvasSize = getRangeMax(particle.size.value) * 2;\n        let emojiData;\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            const canvas = new OffscreenCanvas(canvasSize, canvasSize), context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${getRangeMax(particle.size.value) * 2}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, getRangeMax(particle.size.value), getRangeMax(particle.size.value));\n            emojiData = canvas.transferToImageBitmap();\n        }\n        else {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = canvasSize;\n            canvas.height = canvasSize;\n            const context = canvas.getContext(\"2d\");\n            if (!context) {\n                return;\n            }\n            context.font = `400 ${getRangeMax(particle.size.value) * 2}px ${font}`;\n            context.textBaseline = \"middle\";\n            context.textAlign = \"center\";\n            context.fillText(emoji, getRangeMax(particle.size.value), getRangeMax(particle.size.value));\n            emojiData = canvas;\n        }\n        this._emojiShapeDict.set(key, emojiData);\n        particle.emojiData = emojiData;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}